# 데드락
## #부스트코스 #안드로이드 프로그래밍


\# UI에 메인스레드가 컨트롤하게 되있는데 만약 스레드를 하나 만들어서 UI에 직접 접근하면 **데드락**이 발생할 수 있으므로 UI에 접근하는 것은 메인스레드만 허용한다. 만약 서브 스레드가 UI에 접근할 경우, 빌드시에 에러가 발생한다. **근데 데드락은 과연 무엇인가?**


## 데드락(Deadlock)이란?

* 데드락이란 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 **event를 무한히 기다리는 현상**을 말한다. 

=> 예를 들면 , 어떤 일을 처리하기 위해선 p라는 자원과 q라는 자원이 둘 다 필요한데 프로세스 A는 p를 가지고 프로세스 B는 q를 가진다면, 프로세스A는 q가 없기 때문에 q를 얻기 위해 한없이 기다리고 , 프로세스B는 p가 없기 때문에 p를 한없이 기다리는데 이를 데드락이라고 한다.  
<br>=> 위의 \#의 경우에는 UI에 메인스레드와 서브스레드가 동시에 접근할 경우, 시스템이 어떤걸 먼저 처리할지 모르는 데드락이 발생할 수 있다.

## Dining - Philosophers - Problem

\# 식사하는 철학자들의 문제 
<br>\# 이 문제는 데드락을 설명해주는 대표적인 예시로, 여러 프로세스가 동시에 돌아갈 때 교착 상태가 나타나는 원인을 직관적으로 알 수 있다. 

* 문제 설명 : <br>다섯 명의 철학자가 원탁에 앉아 있고, 각자의 앞에는 스파게티가 있고 양옆에 포크가 하나씩 있다. 그리고 각각의 철학자는 다른 철학자에게 말을 할 수 없다. 이때 철학자가 스파게티를 먹기 위해서는 양 옆의 포크를 동시에 들어야 한다. 이때 각각의 철학자가 왼쪽의 포크를 들고 그 다음 오른쪽의 포크를 들어서 스파게티를 먹는 알고리즘을 가지고 있으면, 다섯 철학자는 동시에 왼쪽의 포크를 들 수 있으나 오른쪽의 포크는 이미 가져가진 상태이기 때문에 다섯 명 모두가 무한정 서로를 기다리는 **교착 상태(Deadlock)** 에 빠지게 될 수 있다.<br>또한 어떤 경우에는 동시에 양쪽 포크를 집을 수 없어 식사를 하지 못하는 **기아 상태(Starvation)** 가 발생할 수도 있고, 몇몇 철학자가 다른 철학자보다 식사를 적게 하는 경우가 발생하기도 한다.

```
/* Synchronization variables */
semaphore chopstick[5]; // initially all values are 1 

/* Philosopher i */
do{
  P(chopstick[i]); // 왼쪽 포크 try
  P(chopstick[(i+1) % 5]); // 오른쪽 포크 try
    ...
    eat();
    ...

    V(chopstick[i]); // 왼쪽 포크 release
    V(chopstick[(i+1) % 5]); // 오른쪽 포크 release

    ...
    think();
    ...

} while(1);
```
: P()는 공유자원인 chopstick(젓가락)를 사용하기 전에 chopstick의 값을 1 줄이는 메소드이고(이후 chopstick 의 값이 0이면 다른 프로세스는 chopstick에 접근할 수 없다), V()는 chopstick을 다 사용하고 난 후 chopstick에 대한 값을 1 늘려 다른 프로세스가 chopstick를 사용하도록 하는 메소드이다.  
: 위의 상황에서 context switch(문맥 교환)에 의해 모든 철학자가 P(chopstick\[i]);에만 접근한 상황인 경우, 자기 기준으로 오른쪽 젓가락(P(chopstick\[(i+1) % 5])은 접근할 수 없기 때문에 **데드락(Deadlock)** 에 빠질 수 있다.(모든 철학자가 밥을 먹지 못하는 상황이 발생한다.) 

> 앞의 solution의 문제점

* Deadlock 가능성이 있다.
* 모든 철학자가 동시에 배가 고파져 왼쪽 젓가락을 집어버린 경우

> 해결방안 

* 4명의 철학자만이 테이블에 동시에 앉을 수 있도록 한다.<br>: 5개의 젓가락이 있으므로 4명만 동시에 앉으면 한 명은 양쪽 젓가락을 모두 접근할 수 있으므로 교착상태가 발생하지 않는다. 
* 젓가락을 두 개 모두 잡을 수 있을 때에만 젓가락을 집을 수 있게 한다.<br>: 예시 코드를 통해 알아보자. 
* 비대칭<br> 짝수(홀수) 철학자는 왼쪽(오른쪽) 젓가락부터 집도록<br>: 인덱스 0, 1, 2, 3, 4의 철학자와 젓가락이 있다고 해보자. 따라서 짝수인 0,2,4 철학자는 왼쪽 젓가락인 0,2,4에 먼저 접근하고 홀수인 1, 3 철학자는 오른쪽 젓가락인 2,4 에 접근할 것이다.(결국 철학자 0 -> 젓가락 0,1 철학자 1 -> 젓가락 2, 철학자 2 -> x , 철학자 3 -> 4,3 철학자 4 -> x ) 젓가락 두개를 모두 접근 가능한 철학자들이 생기므로 따라서 데드락은 발생하지 않는다.

젓가락을 두 개 모두 잡아야지만 젓가락을 집을 수 있는 경우 
```c
enum {thinking, hungry, eating} state[5];
semaphore self[5] = 0;*
semaphore mutex=1;

/* Philosopher i */
do {
  pickup(i);
  eat();
  putdown(i);
  think();
} while(1);


void pickup(int i){
  P(mutex);
  state[i] = hungry;
  test(i);
  V(mutex);
  P(self[i]);
}

void putdown(int i){
  P(mutex);
  state[i] = thinking;
  test((i+4) % 5);
  test((i+1) % 5);
  V(mutex);
}

void test(int i){
  if(state[(i+4) % 5] != eating && state[i] == hungry && state[(i+1) % 5] != eating){
     state[i] = eating;
     V(self[i]);
  }
}
```
=> mutex는 양 옆의 철학자의 상태 값을 동기화 해주어야 하기 때문에 필요하다.